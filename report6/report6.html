<html>
    <head>
        <title>Planet</title>
        <meta charset="UTF-8">
        <script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
    </head>
<body>
    <h1>パーティクルの使用</h1>
    最終作品ではビールを作成するために、パーティクルの設定を行った。<br>
    コップ、ビール、泡全てが透ける必要があったため、透明度の設定を行った。<br>
    泡を一定の範囲内にランダム配置して上昇させたが、上まで到達したら再度下に配置し直すようにした。<br>
    <script>
        // ページの読み込みを待つ
        window.addEventListener('DOMContentLoaded', init);

        function init() {
            // サイズを指定
            const width = 800;
            const height = 600;

            // レンダラーを作成
            var renderer = new THREE.WebGLRenderer({alpha:true});
            document.body.appendChild(renderer.domElement);
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.setClearColor(0x000000);   // 背景の色を設定

            // シーンを作成
            const scene = new THREE.Scene();

            // カメラを作成
            const camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
            camera.position.set(10, 6, 15);

            // カメラコントローラーを作成
            const controls = new THREE.OrbitControls(camera, document.body);

            // 平行光源
            var dirLight = new THREE.DirectionalLight(0x999999);
            dirLight.position.set(6, 10, 6);
            scene.add(dirLight);

            // 環境光源
            const ambLight = new THREE.AmbientLight(0x444444, 0.9);
            scene.add(ambLight);

            // 座標表示
            //const gridHelper = new THREE.GridHelper(2, 10); // size, step
            //scene.add(gridHelper);
            //const axisHelper = new THREE.AxisHelper(2); //軸の長さ　X：赤、Y：緑、z：青
            //scene.add(axisHelper);

            /* コップ、ビールの作成 */
            const cupGeo = new THREE.CylinderGeometry(1.75, 1.5, 5, 32, 16, true);
            const cupMaterial = new THREE.MeshPhongMaterial({
                transparent: true,
                opacity: 0.25,
                side: THREE.DoubleSide,     // 両面を描画する
                depthTest: false,
                color: 0xFFFFFF
            });
            const cup = new THREE.Mesh(cupGeo, cupMaterial);
            cup.position.set(0, 0, 0);
            scene.add(cup);

            const cupPlaneGeo = new THREE.CircleGeometry(1.5, 32);
            const cupPlaneMaterial = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
            const cupPlane = new THREE.Mesh(cupPlaneGeo, cupMaterial);
            cupPlane.rotation.set(-Math.PI / 2, 0, 0);
            cupPlane.position.set(0, -2.5, 0);
            scene.add(cupPlane);

            const beerGeo = new THREE.CylinderGeometry(1.6, 1.4, 4, 32);
            const beerMaterial = new THREE.MeshPhongMaterial({
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
                color: 0xDAA520
            });
            const beer = new THREE.Mesh(beerGeo, beerMaterial);
            beer.position.set(0, -0.4, 0);
            scene.add(beer);

            const hopGeo = new THREE.CylinderGeometry(1.66, 1.6, 0.8, 32);
            const hopMaterial = new THREE.MeshPhongMaterial({
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,     // 両面を描画する
                color: 0xffffff
            });
            const hop = new THREE.Mesh(hopGeo, hopMaterial);
            hop.position.set(0, 2, 0);
            scene.add(hop);

            const length = 300;
            const bubbles = [];
            const xSize = 2;
            const ySize = 3.6;   
            for(let i = 0; i < length; i++){
                let bubbleGeo = new THREE.SphereGeometry( 0.06, 16, 16 );
                var bubbleMaterial = new THREE.MeshPhongMaterial({
                    transparent: true,
                    opacity: 0.9,
                    color: 0xffffff
                });
                bubbles[i] = new THREE.Mesh( bubbleGeo, bubbleMaterial );
                bubbles[i].position.x = xSize * (Math.random() - 0.5);
                bubbles[i].position.y = ySize * (Math.random() - 0.5) - 0.4;
                bubbles[i].position.z = xSize * (Math.random() - 0.5);
                scene.add( bubbles[i] );
            }

            update();

            // ループイベント
            function update() {
                // レンダリング
                renderer.render(scene, camera);
                requestAnimationFrame(update);

                for(let i = 0; i < length; i++){
                    bubbles[i].position.y += 0.05;
                    if (bubbles[i].position.y > 1.5) {
                        bubbles[i].position.x = xSize * (Math.random() - 0.5);
                        bubbles[i].position.y = -2.2;
                        bubbles[i].position.z = xSize * (Math.random() - 0.5);
                    }
                }
            }
        }
    </script>
</body>
</html>
